# This file contains the hierarchy of classes that implement a kernel's
# Abstract Syntax Tree (ast)

# This dictionary is used as a template generator for simple exprs and commands
util = {}

util.update({
    "point": lambda p: "[%s]" % p,
    "assign": lambda s, e: "%s = %s" % (s, e),
    "wrap": lambda e: "(%s)" % e,
    "decl": lambda q, t, s, a, e: "%s%s %s %s= %s;" % (q, t, s, a, e)
})

# Base classes of the AST ###


class Node(object):

    """The base class of the AST."""

    def __init__(self):
        self.children = []

    def gencode(self):
        code = ""
        for n in self.children:
            code += n.gencode() + "\n"
        return code


class Root(Node):

    """Root of the AST."""

    def __init__(self, children):
        Node.__init__(self)
        self.children = children

    def gencode(self):
        header = 'This code is generated by reading an AST\n'
        return header + Node.gencode(self)


# Expressions ###

class Expr(Node):

    def __init__(self):
        Node.__init__(self)


class BinExpr(Expr):

    def __init__(self, expr1, expr2):
        Expr.__init__(self)
        self.children.append(expr1)
        self.children.append(expr2)


class UnExpr(Expr):

    def __init__(self, expr):
        Expr.__init__(self)
        self.children.append(expr)


class Parentheses(UnExpr):

    def __init__(self, expr):
        UnExpr.__init__(self, expr)

    def gencode(self):
        return util["wrap"](self.children[0].gencode())


class Sum(BinExpr):

    def __init__(self, expr1, expr2):
        BinExpr.__init__(self, expr1, expr2)

    def gencode(self):
        return " + ".join([n.gencode() for n in self.children])


class Symbol(Expr):

    """A generic symbol. Rank 0 = scalar, rank 1 = array, rank 2 = matrix, etc.
    rank is a tuple whose entries represent iteration variables the symbol
    depends on or explicit numbers. """

    def __init__(self, symbol, rank):
        Expr.__init__(self)
        self.symbol = symbol
        self.rank = rank

    def gencode(self):
        points = ""
        for p in self.rank:
            points += util["point"](p)
        return str(self.symbol) + points


# Statements ###

class Assign(Node):

    def __init__(self, sym, exp):
        Node.__init__(self)
        self.children.append(sym)
        self.children.append(exp)

    def gencode(self):
        return util["assign"](self.children[0].gencode(),
                              self.children[1].gencode())


class Decl(Node):

    """syntax: [qualifiers] typ sym [attributes] [= init];
    e.g. static const double FE0[3][3] __attribute__(align(32)) = {{...}};
    """

    def __init__(self, typ, sym, init="", qualifiers=[], attributes=[]):
        Node.__init__(self)
        self.typ = typ
        self.sym = sym
        self.init = init
        self.qual = qualifiers
        self.att = attributes

    def gencode(self):

        def spacer(v):
            if v:
                return " ".join(self.qual) + " "
            else:
                return ""

        return util["decl"](spacer(self.qual), self.typ, self.sym.gencode(),
                            spacer(self.att), self.init)

group opencl_indirect;

indirect_loop(parloop,const,op2const)::=<<
$header()$
$parloop._global_reduction_args:{$reduction_kernel()$};separator="\n"$

$if(op2const.keys)$
/* op2 const declarations */
$op2const.values:{c | $opencl_const_declaration(cst=c)$};separator="\n"$
$endif$

$parloop._kernel._inst_code$
$kernel_stub()$
>>

opencl_const_declaration(cst)::=<<
__constant $cst._cl_type$ $cst._name$ $if(cst._is_scalar)$ = $cst._cl_value$$else$[] = {$cst._cl_value;separator=", "$}$endif$;
>>

kernel_stub()::=<<
__kernel
__attribute__((reqd_work_group_size($const.threads_per_block$, 1, 1)))
void $parloop._kernel._name$_stub(
  $parloop._unique_dats:{__global $it._cl_type$* $it._name$,};separator="\n"$
  $parloop._global_non_reduction_args:{__global $it._dat._cl_type$* $it._dat._name$,};separator="\n"$
  $parloop._dat_map_pairs:{__global int* $shared_indirection_mapping_arg_name()$,};separator="\n"$
  $parloop._args:{$if(it._is_indirect)$__global short* $mappingarrayname()$,$endif$};separator="\n"$
  $parloop._global_reduction_args:{__global $it._dat._cl_type$* $global_reduc_device_array_name()$,};separator="\n"$
  __global int* p_ind_sizes,
  __global int* p_ind_offsets,
  __global int* p_blk_map,
  __global int* p_offset,
  __global int* p_nelems,
  __global int* p_nthrcol,
  __global int* p_thrcol,
  __private int block_offset
//    TODO deal with the constants
)
{
  __local char shared [$const.dynamic_shared_memory_size$] __attribute__((aligned(sizeof(long))));
  __local int shared_memory_offset;
  __local int active_threads_count;

  int nbytes;
  int block_id;

  int i_1;

$if(parloop._indirect_reduc_args)$
  __local int colors_count;
  __local int active_threads_count_ceiling;
  int color_1;
  int color_2;
  int i_2;
  // reduction args
  $parloop._indirect_reduc_args:{$it._dat._cl_type$ $reduc_arg_local_name()$[$it._dat._dim$];};separator="\n"$
$endif$

$if(parloop._global_reduction_args)$
  // global reduction local declarations
  $parloop._global_reduction_args:{$it._dat._cl_type$ $global_reduc_local_name()$[$it._dat._dim$];};separator="\n"$
$endif$

  // shared indirection mappings
  $parloop._dat_map_pairs:{__global int* __local $shared_indirection_mapping_name()$;};separator="\n"$
  $parloop._dat_map_pairs:{__local int $shared_indirection_mapping_size_name()$;};separator="\n"$
  $parloop._dat_map_pairs:{__local $it._dat._cl_type$* __local $shared_indirection_mapping_memory_name()$;};separator="\n"$
  $parloop._dat_map_pairs:{const int $shared_indirection_mapping_idx_name()$ = $i0$;};separator="\n"$

  $parloop._nonreduc_vec_dat_map_pairs:{__local $it._dat._cl_type$* $dat_vec_name()$[$it._map._dim$];};separator="\n"$
  $parloop._reduc_vec_dat_map_pairs:{$it._dat._cl_type$* $dat_vec_name()$[$it._map._dim$];};separator="\n"$

  if (get_local_id(0) == 0)
  {
    block_id = p_blk_map[get_group_id(0) + block_offset];
    active_threads_count = p_nelems[block_id];
$if(parloop._indirect_reduc_args)$
    active_threads_count_ceiling = get_local_size(0) * (1 + (active_threads_count - 1) / get_local_size(0));
    colors_count = p_nthrcol[block_id];$endif$
    shared_memory_offset = p_offset[block_id];

    $parloop._dat_map_pairs:{$shared_indirection_mapping_size_name()$ = p_ind_sizes[$shared_indirection_mapping_idx_name()$ + block_id * $const.ninds$];};separator="\n"$

    $parloop._dat_map_pairs:{$shared_indirection_mapping_name()$ = $shared_indirection_mapping_arg_name()$ + p_ind_offsets[$shared_indirection_mapping_idx_name()$ + block_id * $const.ninds$];};separator="\n"$

    nbytes = 0;
    $parloop._dat_map_pairs:{$shared_indirection_mapping_memory_name()$ = (__local $it._dat._cl_type$*) (&shared[nbytes]);
nbytes += ROUND_UP($shared_indirection_mapping_size_name()$ * $it._dat._dim$ * sizeof($it._dat._cl_type$));};separator="\n"$
  }
  barrier(CLK_LOCAL_MEM_FENCE);

$if(parloop._read_dat_map_pairs)$
  // staging in of indirect dats
  $parloop._read_dat_map_pairs:stagingin();separator="\n"$
  barrier(CLK_LOCAL_MEM_FENCE);
$endif$

$if(parloop._indirect_reduc_dat_map_pairs)$
  // zeroing local memory for indirect reduction
  $parloop._indirect_reduc_dat_map_pairs:shared_memory_reduc_zeroing();separator="\n"$
  barrier(CLK_LOCAL_MEM_FENCE);
$endif$

$if(parloop._global_reduction_args)$
  // zeroing private memory for global reduction
  $parloop._global_reduction_args:{$global_reduction_local_zeroing()$};separator="\n"$
$endif$

$if(parloop._indirect_reduc_args)$
  for (i_1 = get_local_id(0); i_1 < active_threads_count_ceiling; i_1 += get_local_size(0)) {
    color_2 = -1;
    if (i_1 < active_threads_count)
    {
      $parloop._indirect_reduc_args:{$staged_arg_local_variable_zeroing()$};separator="\n"$

      $kernel_call()$
      color_2 = p_thrcol[i_1 + shared_memory_offset];
    }
    for (color_1 = 0; color_1 < colors_count; ++color_1)
    {
      // should there be a if + barrier pattern for each indirect reduction argument ?
      if (color_2 == color_1)
      {
        $parloop._indirect_reduc_args:{$reduction()$};separator="\n"$
      }
      barrier(CLK_LOCAL_MEM_FENCE);
    }
  }
$else$
  for (i_1 = get_local_id(0); i_1 < active_threads_count; i_1 += get_local_size(0))
  {
    $kernel_call()$
  }
$endif$

$if(parloop._indirect_reduc_dat_map_pairs)$
  $parloop._indirect_reduc_dat_map_pairs:{$reduction2()$};separator="\n"$
$endif$
$if(parloop._written_dat_map_pairs)$
  // staging out indirect dats
  barrier(CLK_LOCAL_MEM_FENCE);
  $parloop._written_dat_map_pairs:{$stagingout()$};separator="\n"$
$endif$
$if(parloop._global_reduction_args)$
  barrier(CLK_LOCAL_MEM_FENCE);
  // on device global reductions
  $parloop._global_reduction_args:{$on_device_global_reduction()$};separator="\n"$
$endif$
}
>>

shared_memory_reduc_zeroing()::=<<
for (i_1 = get_local_id(0); i_1 < $shared_indirection_mapping_size_name()$ * $it._dat._dim$; i_1 += get_local_size(0))
{
  $shared_indirection_mapping_memory_name()$[i_1] = 0;
}
>>

kernel_call()::=<<
$parloop._actual_args:{$if(it._is_vec_map)$$populate_vec_map()$$endif$};separator="\n"$
$parloop._kernel._name$(
  $parloop._actual_args:{$kernel_call_arg()$};separator=",\n"$
);
>>

kernel_call_arg()::=<<$if(it._is_direct)$(__global $it._dat._cl_type$* __private) ($it._dat._name$ + (i_1 + shared_memory_offset) * $it._dat._dim$)$elseif(it._is_vec_map)$$dat_vec_name()$$elseif(it._is_global_reduction)$$global_reduc_local_name()$$elseif(it._is_indirect_reduction)$$reduc_arg_local_name()$$elseif(it._is_global)$$it._dat._name$$else$&$shared_indirection_mapping_memory_name()$[$mappingarrayname()$[i_1 + shared_memory_offset] * $it._dat._dim$]$endif$>>

populate_vec_map()::=<<
// populate vec map
$if(it._is_reduction)$
$it._i_gen_vec:{$dat_vec_name()$[$it._idx$] = $reduc_arg_local_name()$;};separator="\n"$
$else$
$it._i_gen_vec:{$dat_vec_name()$[$it._idx$] = &$shared_indirection_mapping_memory_name()$[$mappingarrayname()$[i_1 + shared_memory_offset] * $it._dat._dim$];};separator="\n"$
$endif$
>>

staged_arg_local_variable_zeroing()::=<<
for (i_2 = 0; i_2 < $it._dat._dim$; ++i_2)
{
  $reduc_arg_local_name()$[i_2] = $it._dat._cl_type_zero$;
}
>>

reduction()::=<<
for (i_2 = 0; i_2 < $it._dat._dim$; ++i_2)
{
  $if(it._is_INC)$
  $shared_indirection_mapping_memory_name()$[i_2 + $mappingarrayname()$[i_1 + shared_memory_offset] * $it._dat._dim$] += $reduc_arg_local_name()$[i_2];
  $elseif(it._is_MIN)$
  $shared_indirection_mapping_memory_name()$[i_2 + $mappingarrayname()$[i_1 + shared_memory_offset] * $it._dat._dim$] = MIN($shared_indirection_mapping_memory_name()$[i_2 + $mappingarrayname()$[i_1 + shared_memory_offset] * $it._dat._dim$], $reduc_arg_local_name()$[i_2]);
  $elseif(it._is_MAX)$
  $shared_indirection_mapping_memory_name()$[i_2 + $mappingarrayname()$[i_1 + shared_memory_offset] * $it._dat._dim$] =MAX($shared_indirection_mapping_memory_name()$[i_2 + $mappingarrayname()$[i_1 + shared_memory_offset] * $it._dat._dim$], $reduc_arg_local_name()$[i_2]);
  $else$
  SOMETHING WENT SOUTH
  $endif$
}
>>

reduction2()::=<<
for (i_1 = get_local_id(0); i_1 < $shared_indirection_mapping_size_name()$ * $it._dat._dim$; i_1 += get_local_size(0))
{
  $it._dat._name$[i_1 % $it._dat._dim$ + $shared_indirection_mapping_name()$[i_1 / $it._dat._dim$] * $it._dat._dim$] += $shared_indirection_mapping_memory_name()$[i_1];
}
>>

stagingin()::=<<
for (i_1 = get_local_id(0); i_1 < $shared_indirection_mapping_size_name()$ * $it._dat._dim$; i_1 += get_local_size(0))
{
  $shared_indirection_mapping_memory_name()$[i_1] = $dat_arg_name()$[i_1 % $it._dat._dim$ + $shared_indirection_mapping_name()$[i_1 / $it._dat._dim$] * $it._dat._dim$];
}
>>

stagingout()::=<<
for (i_1 = get_local_id(0); i_1 < $shared_indirection_mapping_size_name()$ * $it._dat._dim$; i_1 += get_local_size(0))
{
  $it._dat._name$[i_1 % $it._dat._dim$ + $shared_indirection_mapping_name()$[i_1 / $it._dat._dim$] * $it._dat._dim$] = $shared_indirection_mapping_memory_name()$[i_1];
}
>>

global_reduction_local_zeroing()::=<<
for (i_1 = 0; i_1 < $it._dat._dim$; ++i_1)
{
  $global_reduc_local_name()$[i_1] = $it._dat._cl_type_zero$;
}
>>

on_device_global_reduction()::=<<
// THIS TEMPLATE SHOULD BE FACTORISED WITH DIRECT LOOPS REDUCTIONS
for (i_1 = 0; i_1 < $it._dat._dim$; ++i_1)
{
  $it._dat._name$_reduction_kernel(&$global_reduc_device_array_name()$[i_1 + get_group_id(0) * $it._dat._dim$], $global_reduc_local_name()$[i_1], (__local $it._dat._cl_type$*) shared);
}
>>

mappingarrayname()::=<<mapping_array_$it._dat._name$_at_$it._idx$_via$it._map._name$>>

global_reduc_local_name()::=<<$it._dat._name$_gbl_reduc_local>>
global_reduc_device_array_name()::=<<$it._dat._name$_gbl_reduc_device_array>>
dat_vec_name()::=<<$it._dat._name$_via_$it._map._name$_vec>>
reduc_arg_local_name()::=<<$it._dat._name$_via_$it._map._name$_at_$it._idx$_local>>
dat_arg_name()::=<<$it._dat._name$>>
shared_indirection_mapping_name()::=<<$it._dat._name$_via_$it._map._name$_indirection_map>>
shared_indirection_mapping_size_name()::=<<$it._dat._name$_via_$it._map._name$_indirection_size>>
shared_indirection_mapping_memory_name()::=<<$it._dat._name$_via_$it._map._name$_indirection>>
shared_indirection_mapping_idx_name()::=<<$it._dat._name$_via_$it._map._name$_idx>>
shared_indirection_mapping_arg_name()::=<<ind_$it._dat._name$_via_$it._map._name$_map>>

header()::=<<
/* Launch configuration:
 *   work group count     : $const.block_count$
 *   work group size      : $const.threads_per_block$
 *   partition size       : $const.partition_size$
 *   local memory size    : $const.dynamic_shared_memory_size$
 *   shared memory offset : $const.shared_memory_offset$
 *   warpsize             : $const.warpsize$
 */
#if defined(cl_khr_fp64)
#pragma OPENCL EXTENSION cl_khr_fp64 : enable
#elif defined(cl_amd_fp64)
#pragma OPENCL EXTENSION cl_amd_fp64 : enable
#endif

#define ROUND_UP(bytes) (((bytes) + 15) & ~15)
#define OP_WARPSIZE $const.warpsize$
#define MIN(a,b) ((a < b) ? (a) : (b))
#define MAX(a,b) ((a < b) ? (b) : (a))
>>

reduction_kernel()::=<<
__kernel
void $it._dat._name$_reduction_kernel (
  __global $it._dat._cl_type$* reduction_result,
  __private $it._dat._cl_type$ input_value,
  __local $it._dat._cl_type$* reduction_tmp_array
)
{
  barrier(CLK_LOCAL_MEM_FENCE);
  int lid = get_local_id(0);
  reduction_tmp_array[lid] = input_value;
  barrier(CLK_LOCAL_MEM_FENCE);

  for(int offset = 1;
      offset < (int) get_local_size(0);
      offset <<= 1)
  {
    int mask = (offset << 1) - 1;
    if ( ((lid & mask) == 0) && ((lid + offset) < (int) get_local_size(0)) ) {
      $reduction_op()$
    }
    barrier(CLK_LOCAL_MEM_FENCE);
  }
  if (lid == 0)
  {
    *reduction_result = reduction_tmp_array[0];
  }
}
>>

reduction_op()::=<<$if(it._is_INC)$
reduction_tmp_array[lid] += reduction_tmp_array[lid + offset];
$elseif(it._is_MIN)$
reduction_tmp_array[lid] += MIN(reduction_tmp_array[lid], reduction_tmp_array[lid + offset]);
$elseif(it._is_MAX)$
reduction_tmp_array[lid] += MAX(reduction_tmp_array[lid], reduction_tmp_array[lid + offset]);
$else$
SOMETHING WENT SOUTH;
$endif$>>
